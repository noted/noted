.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "..::docs::memcached_set 3"
.TH ..::docs::memcached_set 3 "2013-05-25" "" "libmemcached"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
memcached_set, memcached_add, memcached_replace \- Store value on server
.SH "LIBRARY"
.IX Header "LIBRARY"
C Client Library for memcached (libmemcached, \-lmemcached)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <memcached.h>
\&
\&  memcached_return
\&    memcached_set (memcached_st *ptr,
\&                   const char *key, size_t key_length, 
\&                   const char *value, size_t value_length, 
\&                   time_t expiration,
\&                   uint32_t flags);
\&
\&  memcached_return
\&    memcached_add (memcached_st *ptr,
\&                   const char *key, size_t key_length,
\&                   const char *value, size_t value_length, 
\&                   time_t expiration,
\&                   uint32_t flags);
\&
\&  memcached_return
\&    memcached_replace (memcached_st *ptr,
\&                       const char *key, size_t key_length,
\&                       const char *value, size_t value_length, 
\&                       time_t expiration,
\&                       uint32_t flags);
\&
\&  memcached_return 
\&    memcached_prepend(memcached_st *ptr, 
\&                      const char *key, size_t key_length,
\&                      const char *value, size_t value_length, 
\&                      time_t expiration,
\&                      uint32_t flags)
\&
\&  memcached_return 
\&    memcached_append(memcached_st *ptr, 
\&                     const char *key, size_t key_length,
\&                      const char *value, size_t value_length, 
\&                      time_t expiration,
\&                      uint32_t flags)
\&  memcached_return 
\&    memcached_cas(memcached_st *ptr, 
\&                  const char *key, size_t key_length,
\&                  const char *value, size_t value_length, 
\&                  time_t expiration,
\&                  uint32_t flags,
\&                  uint64_t cas);
\&
\&  memcached_return 
\&    memcached_set_by_key(memcached_st *ptr, 
\&                         const char *master_key, size_t master_key_length, 
\&                         const char *key, size_t key_length, 
\&                         const char *value, size_t value_length, 
\&                         time_t expiration,
\&                         uint32_t flags);
\&
\&  memcached_return 
\&    memcached_add_by_key(memcached_st *ptr, 
\&                         const char *master_key, size_t master_key_length,
\&                         const char *key, size_t key_length,
\&                         const char *value, size_t value_length, 
\&                         time_t expiration,
\&                         uint32_t flags);
\&
\&  memcached_return 
\&    memcached_replace_by_key(memcached_st *ptr, 
\&                             const char *master_key, size_t master_key_length,
\&                             const char *key, size_t key_length,
\&                             const char *value, size_t value_length, 
\&                             time_t expiration,
\&                             uint32_t flags);
\&
\&  memcached_return 
\&    memcached_prepend_by_key(memcached_st *ptr, 
\&                             const char *master_key, size_t master_key_length,
\&                             const char *key, size_t key_length,
\&                             const char *value, size_t value_length, 
\&                             time_t expiration,
\&                             uint32_t flags);
\&
\&  memcached_return 
\&    memcached_append_by_key(memcached_st *ptr, 
\&                            const char *master_key, size_t master_key_length,
\&                            const char *key, size_t key_length,
\&                            const char *value, size_t value_length, 
\&                            time_t expiration,
\&                            uint32_t flags);
\&
\&  memcached_return 
\&    memcached_cas_by_key(memcached_st *ptr, 
\&                         const char *master_key, size_t master_key_length,
\&                         const char *key, size_t key_length,
\&                         const char *value, size_t value_length, 
\&                         time_t expiration,
\&                         uint32_t flags,
\&                         uint64_t cas);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fImemcached_set()\fR, \fImemcached_add()\fR, and \fImemcached_replace()\fR are all used to
store information on the server. All methods take a key, and its length to
store the object. Keys are currently limited to 250 characters by the
\&\fImemcached\fR\|(1) server. You must also supply a value and a length. Optionally you
may support an expiration time for the object and a 16 byte value (it is
meant to be used as a bitmap).
.PP
\&\fImemcached_set()\fR will write an object to the server. If an object already
exists it will overwrite what is in the server. If the object does not exist
it will be written. If you are using the non-blocking mode this function
will always return true unless a network error occurs.
.PP
\&\fImemcached_replace()\fR replaces an object on the server. If the object is not
found on the server an error occurs.
.PP
\&\fImemcached_add()\fR adds an object to the server. If the object is found on the
server an error occurs, otherwise the value is stored.
.PP
\&\fImemcached_prepend()\fR places a segment of data before the last piece of data 
stored. Currently expiration and key are not used in the server.
.PP
\&\fImemcached_append()\fR places a segment of data at the end of the last piece of 
data stored. Currently expiration and key are not used in the server.
.PP
\&\fImemcached_cas()\fR overwrites data in the server as long as the \*(L"cas\*(R" value is 
still the same in the server. You can get the cas value of a result by 
calling \fImemcached_result_cas()\fR on a \fImemcached_result_st\fR\|(3) structure. At the point 
that this note was written cas is still buggy in memached. Turning on support
for it in \fIlibmemcached\fR\|(3) is optional. Please see \fImemcached_set()\fR for 
information on how to do this.
.PP
\&\fImemcached_set_by_key()\fR, \fImemcached_add_by_key()\fR, \fImemcached_replace_by_key()\fR, 
\&\fImemcached_prepend_by_key()\fR, \fImemcached_append_by_key_by_key()\fR, 
\&\fImemcached_cas_by_key()\fR methods all behave in a similar method as the non key 
methods. The difference is that they use their master_key parameter to map
objects to particular servers.
.PP
If you are looking for performance, \fImemcached_set()\fR with non-blocking \s-1IO\s0 is 
the fastest way to store data on the server.
.PP
All of the above functions are supported with the \f(CW\*(C`MEMCACHED_BEHAVIOR_USE_UDP\*(C'\fR
behavior enabled. But when using these operations with this behavior on, there 
are limits to the size of the payload being sent to the server.  The reason for 
these limits is that the Memcahed Server does not allow multi-datagram requests
and the current server implementation sets a datagram size to 1400 bytes. Due 
to protocol overhead, the actual limit of the user supplied data is less than 
1400 bytes and depends on the protocol in use as well as the operation being 
executed. When running with the binary protocol, \f(CW\*(C` MEMCACHED_BEHAVIOR_BINARY_PROTOCOL\*(C'\fR, 
the size of the key,value, flags and expiry combined may not exceed 1368 bytes. 
When running with the \s-1ASCII\s0 protocol, the exact limit fluctuates depending on 
which function is being executed and whether the function is a cas operation 
or not. For non-cas \s-1ASCII\s0 set operations, there are at least 1335 bytes available 
to split among the key, key_prefix, and value; for cas \s-1ASCII\s0 operations there are 
at least 1318 bytes available to split among the key, key_prefix and value. If the
total size of the command, including overhead, exceeds 1400 bytes, a \f(CW\*(C`MEMCACHED_WRITE_FAILURE\*(C'\fR
will be returned.
.SH "RETURN"
.IX Header "RETURN"
All methods return a value of type \f(CW\*(C`memcached_return\*(C'\fR.
On success the value will be \f(CW\*(C`MEMCACHED_SUCCESS\*(C'\fR.
Use \fImemcached_strerror()\fR to translate this value to a printable string.
.PP
For \fImemcached_replace()\fR and \fImemcached_add()\fR, \f(CW\*(C`MEMCACHED_NOTSTORED\*(C'\fR is a
legitmate error in the case of a collision.
.SH "HOME"
.IX Header "HOME"
To find out more information please check:
<http://tangent.org/552/libmemcached.html>
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Aker, <brian@tangent.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fImemcached\fR\|(1) \fIlibmemached\fR\|(3) \fImemcached_strerror\fR\|(3)
