.\" Automatically generated by Pod::Man 2.23 (Pod::Simple 3.14)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "..::docs::memcached_get 3"
.TH ..::docs::memcached_get 3 "2013-05-25" "" "libmemcached"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
memcached_get, memcached_get_len, memcached_mget, memcached_mget_len, memcached_fetch \- Get a value
.SH "LIBRARY"
.IX Header "LIBRARY"
C Client Library for memcached (libmemcached, \-lmemcached)
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
.Vb 1
\&  #include <memcached.h>
\&
\&  memcached_result_st *
\&  memcached_fetch_result(memcached_st *ptr, 
\&                       memcached_result_st *result,
\&                       memcached_return *error);
\&
\&  char *memcached_get(memcached_st *ptr,
\&                      const char *key, size_t key_length,
\&                      size_t *value_length, 
\&                      uint32_t *flags,
\&                      memcached_return *error);
\&
\&  memcached_return
\&  memcached_mget(memcached_st *ptr, 
\&                 char **keys, size_t *key_length, 
\&                 size_t number_of_keys);
\&  char *
\&  memcached_get_by_key(memcached_st *ptr, 
\&                       const char *master_key, size_t master_key_length, 
\&                       const char *key, size_t key_length, 
\&                       uint32_t user_spec_len,
\&                       size_t *value_length, 
\&                       uint32_t *flags,
\&                       memcached_return *error);
\&
\&  memcached_return 
\&  memcached_mget_by_key(memcached_st *ptr, 
\&                        const char *master_key, size_t master_key_length,
\&                        char **keys, size_t *key_length, 
\&                        size_t number_of_keys,
\&                       uint32_t user_spec_len);
\&
\&  char *memcached_fetch(memcached_st *ptr,
\&                        char *key, size_t *key_length, 
\&                        size_t *value_length,
\&                        uint32_t *flags, 
\&                        memcached_return *error);
\&  memcached_return 
\&  memcached_fetch_execute(memcached_st *ptr, 
\&                          memcached_return (*callback[])(memcached_st *ptr, memcached_result_st *result, void *context),
\&                          void *context,
\&                          unsigned int number_of_callbacks);
\&
\&  char *
\&  memcached_get_len(memcached_st *ptr, 
\&                    const char *key, size_t key_length,
\&                    uint32_t user_spec_len,
\&                    size_t *value_length, 
\&                    uint32_t *flags,
\&                    memcached_return *error);
\&
\&  memcached_return
\&  memcached_mget_len(memcached_st *ptr, 
\&                     const char **keys, size_t *key_length, 
\&                     size_t number_of_keys, uint32_t user_spec_len);
.Ve
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
\&\fImemcached_get()\fR is used to fetch an individual value from the server. You
must pass in a key and its length to fetch the object. You must supply
three pointer variables which will give you the state of the returned
object.  A uint32_t pointer to contain whatever flags you stored with the value,
a size_t pointer which will be filled with size of of the object, and a
memcached_return pointer to hold any error. The object will be returned
upon success and \s-1NULL\s0 will be returned on failure. Any object returned by
\&\fImemcached_get()\fR must be released by the caller application.
.PP
\&\fImemcached_get_len()\fR is also used to fetch an individual value from the
server.  The only difference when compared to \fImemcached_get()\fR is that
the server will only send back the first n bytes of the value where n is
specified by the user.  Note that this command is only available when
using the ascii protocol.
.PP
\&\fImemcached_mget()\fR is used to select multiple keys at once. For multiple key
operations it is always faster to use this function. This function always
works asynchronously. \fImemcached_fetch()\fR is then used to retrieve any keys
found. No error is given on keys that are not found. You must call either
\&\fImemcached_fetch()\fR or \fImemcached_fetch_result()\fR after a successful call to
\&\fImemcached_mget()\fR. You should continue to call these functions until they
return \s-1NULL\s0 (aka no more values). If you need to quit in the middle of a
\&\fImemcached_get()\fR call, execute a \fImemcached_quit()\fR. After you do this, you can
issue new queries against the server.
.PP
\&\fImemcached_mget_len()\fR is also used to select multiple keys at once.  The
only difference when compared to \fImemcached_mget()\fR is that the server
will only send back the first n bytes of each value where n is
specified by the user.  Note that this command is only available when
using the ascii protocol.
.PP
\&\fImemcached_fetch()\fR is used to fetch an individual value from the server. 
\&\fImemcached_mget()\fR or \fImemcached_mget_len()\fR must always be called before
using this method.  You must pass in a key and its length to fetch the
object. You must supply three pointer variables which will give you the
state of the returned object.  A uint32_t pointer to contain whatever
flags you stored with the value, a size_t pointer which will be filled
with size of of the object, and a memcached_return pointer to hold any
error. The object will be returned upon success and \s-1NULL\s0 will be returned
on failure. \s-1MEMCACHD_END\s0 is returned by the *error value when all objects
that have been found are returned.  The final value upon \s-1MEMCACHED_END\s0 is
null. Values returned by \fImemcached_fetch()\fR musted be free'ed by the caller.
.PP
\&\fImemcached_fetch_result()\fR is used to return a \fImemcached_result_st\fR\|(3) structure 
from a memcached server. The result object is forward compatible with changes
to the server. For more information please refer to the \fImemcached_result_st\fR\|(3) 
help. This function will dynamically allocate a result structure for you
if you do not pass one to the function.
.PP
\&\fImemcached_fetch_execute()\fR is a callback function for result sets. Instead
of returning the results to you for processing, it passes each of the
result sets to the list of functions you provide. It passes to the function
a memcached_st that can be cloned for use in the called function (it can not 
be used directly). It also passes a result set which does not need to be freed.
Finally it passes a \*(L"context\*(R". This is just a pointer to a memory reference
you supply the calling function. Currently only one value is being passed
to each function call. In the future there will be an option to allow this
to be an array.
.PP
\&\fImemcached_get_by_key()\fR and \fImemcached_mget_by_key()\fR behave in a similar nature
as \fImemcached_get()\fR and \fImemcached_mget()\fR. The difference is that they take
a master key that is used for determining which server an object was stored
if key partitioning was used for storage.
.PP
All of the above functions are not supported when the \f(CW\*(C`MEMCACHED_BEHAVIOR_USE_UDP\*(C'\fR
has been set. Executing any of these functions with this behavior on will result in 
\&\f(CW\*(C`MEMCACHED_NOT_SUPPORTED\*(C'\fR being returned or, for those functions which do not return
a \f(CW\*(C`memcached_return\*(C'\fR, the error function parameter will be set to 
\&\f(CW\*(C`MEMCACHED_NOT_SUPPORTED\*(C'\fR.
.SH "RETURN"
.IX Header "RETURN"
All objects returned must be freed by the calling application.
\&\fImemcached_get()\fR, \fImemcached_get_len()\fR, and \fImemcached_fetch()\fR will return
\&\s-1NULL\s0 on error. You must look at the value of error to determine what
the actual error was.
.SH "HOME"
.IX Header "HOME"
To find out more information please check:
<http://tangent.org/552/libmemcached.html>
.SH "AUTHOR"
.IX Header "AUTHOR"
Brian Aker, <brian@tangent.org>
.SH "SEE ALSO"
.IX Header "SEE ALSO"
\&\fImemcached\fR\|(1) \fIlibmemcached\fR\|(3) \fImemcached_strerror\fR\|(3)
